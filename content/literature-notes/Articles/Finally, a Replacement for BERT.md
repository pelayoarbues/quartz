---
author: [[Benjamin Warner]]
title: "Finally, a Replacement for BERT"
date: 2024-12-20
tags: 
- articles
- literature-note
---
![rw-book-cover](https://huggingface.co/blog/assets/modernbert/thumbnail.png)

## Metadata
- Author: [[Benjamin Warner]]
- Full Title: Finally, a Replacement for BERT
- URL: https://huggingface.co/blog/modernbert

## Highlights
- This blog post introduces [ModernBERT](https://huggingface.co/collections/answerdotai/modernbert-67627ad707a4acbf33c41deb), a family of state-of-the-art encoder-only models representing improvements over older generation encoders across the board, with a **8192** sequence length, better downstream performance and much faster processing. ([View Highlight](https://read.readwise.io/read/01jfhbnt427n83es0bqsxpa1mp))
- [BERT](https://huggingface.co/papers/1810.04805) was released in 2018 (millennia ago in AI-years!) and yet it’s still widely used today: in fact, it’s currently the second most downloaded model on the [HuggingFace hub](https://huggingface.co/models?sort=downloads), with more than 68 million monthly downloads, only second to [another encoder model fine-tuned for retrieval](https://huggingface.co/sentence-transformers/all-MiniLM-L6-v2). That’s because its *encoder-only architecture* makes it ideal for the kinds of real-world problems that come up every day, like retrieval (such as for RAG), classification (such as content moderation), and entity extraction (such as for privacy and regulatory compliance). ([View Highlight](https://read.readwise.io/read/01jfhbvagppdbj523vnkraeqtr))
- Finally, 6 years later, we have a replacement! Today, we at [Answer.AI](http://Answer.AI) and [LightOn](https://www.lighton.ai/) (and friends!) are releasing ModernBERT. ModernBERT is a new model series that is a Pareto improvement over BERT and its younger siblings across both **speed** and **accuracy**. This model takes dozens of advances from recent years of work on large language models (LLMs), and applies them to a BERT-style model, including updates to the architecture and the training process. ([View Highlight](https://read.readwise.io/read/01jfhbvxt8gephnkwe7q6z0n7f))
- We expect to see ModernBERT become the new standard in the numerous applications where encoder-only models are now deployed, such as in RAG pipelines (Retrieval Augmented Generation) and recommendation systems. ([View Highlight](https://read.readwise.io/read/01jfhc49pd5w91a4wesvvvcypr))
- In addition to being faster and more accurate, ModernBERT also increases context length to 8k tokens (compared to just 512 for most encoders), and is the first encoder-only model that includes a large amount of code in its training data. These features open up new application areas that were previously inaccessible through open models, such as large-scale code search, new IDE features, and new types of retrieval pipelines based on full document retrieval rather than small chunks. ([View Highlight](https://read.readwise.io/read/01jfhc4dqwyb6fcyzktdwtarnh))
- The recent high-profile advances in LLMs have been in models like [GPT](https://huggingface.co/openai-community/openai-gpt), [Llama](https://huggingface.co/meta-llama), and [Claude](https://www.anthropic.com/claude). These are *decoder-only models,* or generative models. Their ability to generate human-like content has enabled astonishing new GenAI application areas like generated art and interactive chat. These striking applications have attracted major investment, funded booming research, and led to rapid technical advances. What we’ve done, essentially, is port these advances back to an encoder-only model. ([View Highlight](https://read.readwise.io/read/01jfhc4z64p3wnhe0yb80gppph))
- More bluntly, decoder-only models are *too big*, *slow*, ***private***, and *expensive* for many jobs. Consider that the original [GPT-1](https://huggingface.co/openai-community/openai-gpt) was a 117 million parameter model. The [Llama 3.1](https://huggingface.co/meta-llama/Llama-3.1-405B) model, by contrast, has 405 *billion* parameters, and its technical report describes a data synthesis and curation recipe that is too complex and expensive for most corporations to reproduce. So to use such a model, like ChatGPT, you pay in cents and wait in seconds to get an API reply back from heavyweight servers outside of your control. ([View Highlight](https://read.readwise.io/read/01jfhc60jjn3yrhzjcwajvygpv))
- Of course, the open-ended capabilities of these giant generative models mean that you can, in a pinch, press them into service for non-generative or *discriminative* tasks, such as classification. This is because you can describe a classification task in plain English and ... just ask the model to classify. But while this workflow is great for prototyping, you don’t want to pay prototype prices once you’re in mass production. ([View Highlight](https://read.readwise.io/read/01jfhc6qcr8bb8gb997e3y0v9n))
- The output of an encoder-only model is a list of numerical values (an *embedding vector*). You might say that instead of answering with text, an encoder model literally *encodes* its “answer” into this compressed, numerical form. That vector is a compressed representation of the model's input, which is why encoder-only models are sometimes referred to as *representational models*. ([View Highlight](https://read.readwise.io/read/01jfhc7z5kd0ef1s4ys6n2hak0))
- While decoder-only models (like a GPT) can do the work of an encoder-only model (like a BERT), they are hamstrung by a key constraint: since they are *generative models*, they are mathematically “not allowed” to “peek” at later tokens. They can only ever *look backwards*. This is in contrast to encoder-only models, which are **trained so each token can look forwards *and* backwards (bi-directionally)**. They are built for this, and it makes them very efficient at what they do. ([View Highlight](https://read.readwise.io/read/01jfhc8gp77p9bazkpaezpp4ph))
- Basically, a frontier model like OpenAI's O1 is like a Ferrari SF-23. It’s an obvious triumph of engineering, designed to win races, and that’s why we talk about it. But it takes a special pit crew just to change the tires and you can’t buy one for yourself. In contrast, a BERT model is like a Honda Civic. It’s *also* an engineering triumph, but more subtly, since *it* is engineered to be affordable, fuel-efficient, reliable, and extremely useful. And that’s why they’re absolutely everywhere. ([View Highlight](https://read.readwise.io/read/01jfhc918kd0sd442myj91rkp6))
- ***Supporting generative models***: One way to understand the prevalence of representational models (encoder-only) is to note how frequently they are used in concert with a decoder-only model to make a system which is safe and efficient. ([View Highlight](https://read.readwise.io/read/01jfhc9fxw4rdzqvscrxyy3b9x))
- The obvious example is RAG. Instead of relying on the LLM’s knowledge trained into the model’s parameters, the system uses a document store to furnish the LLM with information relevant to the query. But of course this only defers the problem. If the LLM doesn’t know which documents are relevant to the query, then the system will need some other process to select those documents? It’s going to need a model which is fast and cheap enough that it can be used to encode the large quantities of information needed to make the LLM useful. That model is often a BERT-like encoder-only model. ([View Highlight](https://read.readwise.io/read/01jfhcb3zxyd244dn9n4ymwhaq))
- Another example is supervision architectures, where a cheap classifier might be used to ensure that generated text does not violate content safety requirements. ([View Highlight](https://read.readwise.io/read/01jfhcbb2ytxj7trne46805686))
- In short, whenever you see a decoder-only model in deployment, there’s a reasonable chance an encoder-only model is also part of the system. But the converse is not true. ([View Highlight](https://read.readwise.io/read/01jfhcbhyvffp24cn01qxj8k7v))
- ***Encoder-based systems***: Before there was GPT, there were content recommendations in social media and in platforms like Netflix. There was ad targeting in those venues, in search, and elsewhere. There was content classification for spam detection, abuse detection, etc.. These systems were not built on generative models, but on representational models like encoder-only models. And all these systems are still out there and still running at enormous scale. Imagine how many ads are targeted per second around the world! ([View Highlight](https://read.readwise.io/read/01jfhcbtdqa1nvyhr1e8try5rx))
- ***Downloads***: On HuggingFace, [RoBERTa](https://huggingface.co/FacebookAI/roberta-base), one of the leading BERT-based models, has more downloads than the 10 most popular LLMs on HuggingFace combined. In fact, currently, encoder-only models add up to over a billion downloads per month, nearly three times more than decoder-only models with their 397 million monthly downloads. In fact, the `fill-mask` model category, composed of encoder “base models” such as ModernBERT, ready to be fine-tuned for other downstream applications, is the most downloaded model category overall. ([View Highlight](https://read.readwise.io/read/01jfhcc8ve95q21kez88h9jp4y))
- ***Inference costs***: What the above suggests, is that on an inference-per-inference basis, there are many times more inferences performed per year on encoder-only models than on decoder-only or generative models. An interesting example is [FineWeb-Edu](https://huggingface.co/spaces/HuggingFaceFW/blogpost-fineweb-v1), where model-based quality filtering had to be performed over 15 trillion tokens. The FineWeb-Edu team chose to generate annotations with a decoder-only model, [Llama-3-70b-Instruct](https://huggingface.co/meta-llama/Meta-Llama-3-70B-Instruct), and perform the bulk of the filtering with [a fine-tuned BERT-based model](https://huggingface.co/HuggingFaceFW/fineweb-edu-classifier). This filtering took 6,000 H100 hours, which, at [HuggingFace Inference Points](https://huggingface.co/pricing)’ pricing of $10/hour, comes to a total of $60,000. On the other hand, feeding 15 trillion tokens to popular decoder-only models, even with the lowest-cost option of using [Google’s Gemini Flash and its low inference cost of $0.075/million tokens](https://ai.google.dev/pricing#1_5flash), would cost over one million dollars! ([View Highlight](https://read.readwise.io/read/01jfhcddtg5tfqa5ctkhtzaz31))
- Here’s a snapshot of the accuracy of ModernBERT and other models across a range of tasks, as measured by standard academic benchmarks – as you can see, ModernBERT is the only model which is a **top scorer across every category**, which makes it the one model you can use for all your encoder-based tasks:
  [![](https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/modernbert/modernbert_accuracy_table.png)](https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/modernbert/modernbert_accuracy_table.png) ([View Highlight](https://read.readwise.io/read/01jfhcdseex9e8mvg8re9sxkeg))
- If you’ve ever done an NLP competition on [Kaggle](https://www.kaggle.com/), then you’ll know that [DeBERTaV3](https://huggingface.co/microsoft/deberta-v3-base) has been the choice of champions for years. But no longer: not only is ModernBERT the first base-size model to beat DeBERTaV3 on GLUE, it also uses less than **1/5th** of Deberta’s memory. ([View Highlight](https://read.readwise.io/read/01jfhcdz7q4wev0adzs5d6d2qn))
- And of course, ModernBERT is fast. It’s **twice** as fast as DeBERTa – in fact, up to **4x** faster in the more common situation where inputs are mixed length. Its long context inference is nearly **3 times** faster than other high-quality models such as [NomicBERT](https://huggingface.co/nomic-ai/nomic-bert-2048) and [GTE-en-MLM](https://huggingface.co/Alibaba-NLP/gte-en-mlm-base). ([View Highlight](https://read.readwise.io/read/01jfhce4ywz8b7hxwykxzjck6b))
- ModernBERT’s context length of 8,192 tokens is over **16x** larger than most existing encoders. This is critical, for instance, in RAG pipelines, where a small context often makes chunks too small for semantic understanding. ModernBERT is also the state-of-the-art long context retriever with [ColBERT](https://huggingface.co/colbert-ir/colbertv2.0), and is 9 percentage points above the other long context models. Even more impressive: this very quickly trained model, simply tuned to compare to other backbones, outperforms even widely-used retrieval models on long-context tasks! ([View Highlight](https://read.readwise.io/read/01jfhcec3gb3cn9k06pn8rbtqq))
- For code retrieval, ModernBERT is unique. There’s nothing to really compare it to, since there’s never been an encoder model like this trained on a large amount of code data before. For instance, on the [StackOverflow-QA dataset (SQA)](https://www.kaggle.com/datasets/imoore/60k-stack-overflow-questions-with-quality-rate), which is a hybrid dataset mixing both code and natural language, ModernBERT's specialized code understanding and long-context capabilities make it the only backbone to score over 80 on this task. ([View Highlight](https://read.readwise.io/read/01jfhcepc9ap8n0b6frt6ewzpy))
- This means whole new applications are likely to be built on this capability. For instance, imagine an AI-connected IDE which had an entire enterprise codebase indexed with ModernBERT embeddings, providing fast long context retrieval of the relevant code across all repositories. Or a code chat service which described how an application feature worked that integrated dozens of separate projects. ([View Highlight](https://read.readwise.io/read/01jfhcf111x2gmhefxf68krep6))
- Now, we’ve made our case to why we **should** give some more love to encoder models. As trusted, under-appreciated workhorses, they’ve had surprisingly few updates since 2018's BERT! ([View Highlight](https://read.readwise.io/read/01jfhcfqt96axaszymacjvp1r4))
- Even more surprising: since RoBERTa, there has been no encoder providing overall improvements without tradeoffs (fancily known as “***Pareto improvements***”): DeBERTaV3 had better GLUE and classification performance, but sacrificed both efficiency and retrieval. Other models, such as [AlBERT](https://huggingface.co/albert/albert-base-v2), or newer ones, like GTE-en-MLM, all improved over the original BERT and RoBERTa in some ways but regressed in others. ([View Highlight](https://read.readwise.io/read/01jfhcg4jeh2nfn7tqw3xnqgj0))
- However, since the duo’s original release, we've learned an enormous amount about how to build better language models. If you’ve used LLMs at all, you’re very well aware of it: while they’re rare in the encoder-world, *Pareto improvements* are constant in decoder-land, where models constantly become better at everything. And as we’ve all learned by now: model improvements are only partially magic, and mostly engineering. ([View Highlight](https://read.readwise.io/read/01jfhcpxmde6v11r0pbwzf1a97))
- The goal of the (hopefully aptly named) ModernBERT project was thus fairly simple: bring this modern engineering to encoder models. We did so in three core ways:
  1. a **modernized transformer architecture**
  2. **particular attention to efficiency**
  3. **modern data scales & sources** ([View Highlight](https://read.readwise.io/read/01jfhcq4wxvm4xy2vspgfjts96))
- The Transformer architecture has become dominant, and is used by the vast majority of models nowadays. However, it’s important to remember that there isn’t one but many *Transformers*. The main thing they share in common is their deep belief that attention is indeed all you need, and as such, build various improvements centered around the attention mechanism. ([View Highlight](https://read.readwise.io/read/01jfhcxx3y9ry8pxwzqazjtmj7))
- ModernBERT takes huge inspiration from the Transformer++ (as coined by [Mamba](https://arxiv.org/abs/2312.00752)), first used by the [Llama2 family of models](https://arxiv.org/abs/2307.09288). Namely, we replace older BERT-like building blocks with their improved equivalent, namely, we:
  • Replace the old positional encoding with ["rotary positional embeddings"](https://huggingface.co/blog/designing-positional-encoding) (RoPE): this makes the model much better at understanding where words are in relation to each other, and allows us to scale to longer sequence lengths.
  • Switch out the old MLP layers for GeGLU layers, improving on the original BERT’s GeLU activation function.
  • Streamline the architecture by removing unnecessary bias terms, letting us spend our parameter budget more effectively
  • Add an extra normalization layer after embeddings, which helps stabilize trainin ([View Highlight](https://read.readwise.io/read/01jfhcynvyg06grama0ws4j8jd))
- We’ve covered this already: encoders are no Ferraris, and ModernBERT is no exception. However, that doesn’t mean it can’t be fast. When you get on the highway, you generally don’t go and trade in your car for a race car, but rather hope that your everyday reliable ride can comfortably hit the speed limit. ([View Highlight](https://read.readwise.io/read/01jfhcytkpc569jsgndvpr39db))
- In fact, for all the application cases we mentioned above, speed is essential. Encoders are very popular in uses where they either have to process tons of data, allowing even tiny speed increments to add up very quickly, or where latency is very important, as is the case on RAG. In a lot of situations, encoders are even run on CPU, where efficiency is even more important if we want results in a reasonable amount of time. ([View Highlight](https://read.readwise.io/read/01jfhcyydwc418c74ems5pe0de))
- As with most things in research, we build while standing on the shoulders of giants, and heavily leverage Flash Attention 2’s speed improvements. Our efficiency improvements rely on three key components: **Alternating Attention**, to improve processing efficiency, **Unpadding and Sequence Packing**, to reduce computational waste, and **Hardware-Aware Model Design**, to maximise hardware utilization.
  [](https://huggingface.co/blog/modernbert/#global-and-local-attention) ([View Highlight](https://read.readwise.io/read/01jfhcz2ywxmre8ejnycy30p4q))
- One of ModernBERT’s most impactful features is **Alternating** **Attention**, rather than full global attention. In technical terms, this means that our attention mechanism only attends to the full input every 3 layers (**global attention**), while all other layers use a sliding window where every token only attends to the 128 tokens nearest to itself (**local attention)**. ([View Highlight](https://read.readwise.io/read/01jfhczhbdtgt4xvapt11gpter))
- As attention’s computational complexity balloons up with every additional token, this means ModernBERT can process long input sequences considerably faster than any other model.
  In practice, it looks like this: 
  [![](https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/modernbert/modernbert_alternating_attention.png)](https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/modernbert/modernbert_alternating_attention.png) ([View Highlight](https://read.readwise.io/read/01jfhd011jvr5y9arhcf47p4cn))
- Conceptually, the reason this works is pretty simple: Picture yourself reading a book. For every sentence you read, do you need to be fully aware of the entire plot to understand most of it (**full global attention**)? Or is awareness of the current chapter enough (**local attention**), as long as you occasionally think back on its significance to the main plot (**global attention**)? In the vast majority of cases, it’s the latter. ([View Highlight](https://read.readwise.io/read/01jfhd0cg9ax2yk4rjjgfdezt4))
- Another core mechanism contributing to ModernBERT’s efficiency is its use for Unpadding and Sequence packing.
  In order to be able to process multiple sequences within the same batch, encoder models require them to be the *same length*, so they can perform parallel computation. Traditionally, we’ve relied on **padding** to achieve this: figure out which sentence is the longest, and add meaningless tokens (*padding tokens*) to fill up every other sequence. ([View Highlight](https://read.readwise.io/read/01jfhe3a3jaahq37vywr5z5tg6))
- While padding solves the problem, it doesn’t do so elegantly: a lot of compute ends up being spent and wasted on padding tokens, which do not contribute any semantic information.
  ![Padding vs sequence packing](https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/modernbert/modernbert_unpadding.png) ([View Highlight](https://read.readwise.io/read/01jfhe3f9esab1k12hymwqb1ar))
- **Unpadding** solves this issue: rather than keeping these padding tokens, we remove them all, and concatenate them into mini-batches with a batch size of one, avoiding all unnecessary computations. If you’re using Flash Attention, our implementation of unpadding is even faster than previous methods, which heavily relied on unpadding and repadding sequences as they went through the model: we go one step further by introducing our own implementation of unpadding, relying heavily on recent developments in Flash Attention’s RoPE support. This allows ModernBERT to only have to unpad once, and optionally repad sequences after processing, resulting in a 10-20% speedup over previous methods. ([View Highlight](https://read.readwise.io/read/01jfhe3pqt44w8b791jqezwjmd))
- To speed up pre-training even further, unpadding is in good company within our model, as we use it in conjunction with **sequence packing.** Sequence packing here is a logical next step: as we’re concatenating inputs into a single sequence, and GPUs are very good at parallelisation, we want to maximise the computational efficiency we can squeeze out of a single forward model pass. To do so, we use a greedy algorithm to group individual sequences into concatenated ones that are as close to the model’s maximum input length as possible. ([View Highlight](https://read.readwise.io/read/01jfhe3sexm7yz6hgnfsvtgs38))


