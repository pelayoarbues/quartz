---
author: [[huggingface.co]]
title: "Faster Text Generation With Self-Speculative Decoding"
date: 2024-11-20
tags: 
- articles
- literature-note
---
![rw-book-cover](https://huggingface.co/blog/assets/layerskip/thumbnail.png)

## Metadata
- Author: [[huggingface.co]]
- Full Title: Faster Text Generation With Self-Speculative Decoding
- URL: https://hf.co/blog/layerskip

## Highlights
- Self-speculative decoding, proposed in [LayerSkip: Enabling Early Exit Inference and Self-Speculative Decoding](https://arxiv.org/abs/2404.16710) is a novel approach to text generation. It combines the strengths of speculative decoding with early exiting from a large language model (LLM). This method allows for efficient generation by using the *same model's* early layers for drafting tokens, and later layers for verification. ([View Highlight](https://read.readwise.io/read/01jd5n61nnr2re719xqaa4hyqh))
- This technique not only speeds up text generation, but it also achieves significant memory savings and reduces computational latency. In order to obtain an end-to-end speedup, the output of the earlier layers need to be close enough to the last layer. This is achieved by a training recipe which, as described in the paper, can be applied during pretraining, and also while fine-tuning on a specific domain. Self-speculative decoding is especially efficient for real-world applications, enabling deployment on smaller GPUs and lowering the overall hardware footprint needed for **large-scale inference**. ([View Highlight](https://read.readwise.io/read/01jd5n6as6m90qwyxcth5k9nct))
- In this blog post, we explore the concept of self-speculative decoding, its implementation, and practical applications using the 🤗 transformers library. You’ll learn about the technical underpinnings, including **early exit layers**, **unembedding**, and **training modifications**. To ground these concepts in practice, we offer code examples, benchmark comparisons with traditional speculative decoding, and insights into performance trade-offs. ([View Highlight](https://read.readwise.io/read/01jd5n7hqypp7emndspk8tgq0a))
- Speculative Decoding and Self-Speculative Decoding
  ![](https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/layerskip-assets/LayerSkip-Demo.gif) ([View Highlight](https://read.readwise.io/read/01jd5n858872y4v8eg67dtt97g))
- [Traditional speculative decoding](https://huggingface.co/blog/assisted-generation) uses **two** models: a smaller one (draft model) to generate a sequence of draft tokens, and a larger one (verification model) to verify the draft’s accuracy. The smaller model performs a significant portion of the generation, while the larger model refines the results. This increases text generation speed since the larger model verifies full sequences at once, instead of generating one draft at a time. ([View Highlight](https://read.readwise.io/read/01jd5n8z006a30d7d9y43j5wkt))
- In self-speculative decoding, the authors build on this concept but use the early layers of a large model to generate draft tokens that are then verified by the model's deeper layers. This "self" aspect of speculative decoding, which requires specific training, allows the model to perform both drafting and verification. This, in turn, improves speed and reduces computational costs compared to the traditional speculative decoding. ([View Highlight](https://read.readwise.io/read/01jd5n96kn00pyz51n4fcs025j))
- **Note:** While the `assistant_early_exit` argument can potentially enable early-exit self-speculative decoding for any decoder-only transformer, the logits from the intermediate layers cannot be **unembedded** (process of decoding through LM Head, described later in the blog post) unless the model is specifically trained for that. You will also **only obtain speedups** for a checkpoint that was trained in such a way to increase the accuracy of earlier layers. The [LayerSkip paper](https://arxiv.org/abs/2404.16710) proposes a training recipe to achieve that (namely, applying early exit loss, and progressively increasing layer dropout rates). A collection of Llama2, Llama3, and Code Llama checkpoints that have been continually pretrained with the LayerSkip training recipe are provided [here](https://huggingface.co/collections/facebook/layerskip-666b25c50c8ae90e1965727a). ([View Highlight](https://read.readwise.io/read/01jd5na33wvxxrazmydf8r7n4y))
- One key technique in self-speculative decoding is early exit, where the generation process can halt at a pre specified layer. To accomplish this, we **unembed** the logits from these layers by projecting them onto the language model (LM) head to predict the next token. This allows the model to skip subsequent layers and improve inference time. ([View Highlight](https://read.readwise.io/read/01jd5nadtwknm4yg9svq09dvdj))
- Unembedding can be performed at any transformer layer, turning early-exit into an efficient token-prediction mechanism. A natural question arises: how can the LM head be adapted to unembed logits from earlier layers when it was initially trained to work with the final layer only? This is where the training modifications come into play. ([View Highlight](https://read.readwise.io/read/01jd5nfb91h5fc0zkpwmtvb31z))
- In the training phase, we introduce **layer dropout**, which allows the model to skip certain layers during training. The dropout rate increases progressively in deeper layers, making the model less reliant on its later layers, as well as enhancing the model's generalization and speeding up training. ([View Highlight](https://read.readwise.io/read/01jd5nfxpd2dpx1rmrt8spfqvf))
- In addition to layer dropout, **early exit loss** is applied to ensure the LM head learns to unembed different layers. The total loss function for training the model with early exits is given by a summation of normalized loss from each exit (intermediate layers). This technique enables efficient training by distributing the learning task across all layers. ([View Highlight](https://read.readwise.io/read/01jd5ngym1adkkbvww572jfw6x))
- Once training is complete, we can apply self-speculative decoding during inference. [The process](https://huggingface.co/docs/transformers/v4.46.3/en/llm_optims#speculative-decoding) begins with **self-drafting**, where tokens are generated by exiting early from some intermediate layer. The number of speculative tokens defines how many draft tokens are produced during this stage, and the layer we exit at defines how large and accurate is the draft stage. Both parameters can be specified at inference based on a [trade-off between speed and accuracy of the draft stage](https://huggingface.co/blog/assisted-generation). ([View Highlight](https://read.readwise.io/read/01jd5nh46ebcz80pc0sh2narbd))
- The next stage is **self-verification**, where the full model is used to verify the draft tokens. The verification model reuses the portion of cache from the draft model. If the draft tokens align with the verified tokens, they are added to the final output, resulting in a better usage of the memory bandwidth in our system, because it’s much more expensive to generate a sequence of tokens with the full model than verifying a draft, as long as several of the tokens match. ([View Highlight](https://read.readwise.io/read/01jd5nhe8wvjam44j1vn7zby3k))
- In the self-verification stage, only the remaining layers are computed for verification, because the results from the early layers are cached during the drafting phase. ([View Highlight](https://read.readwise.io/read/01jd5nhgb9wbykny2fvh789e87))
- Self-speculative decoding benefits significantly from cache reuse, particularly the **KV cache**, which stores key-value pairs computed during the drafting stage. This cache allows the model to skip redundant calculations, as both the draft and verification stages use the same early layers. Additionally, the **exit query cache** stores the query vector from the exit layer, allowing verification to continue seamlessly from the draft stage. ([View Highlight](https://read.readwise.io/read/01jd5nhn08c384r46nat4fqp89))
- Compared to traditional two-model speculative decoding, early-exit self-speculative decoding can benefit from the following savings:
  • **Shared Weights**: Reuses the weights from the first EE layers for both drafting and verification.
  • **Shared KV Cache**: Reuses key-value pairs from the first EE layers for both drafting and verification.
  • **Shared Compute**: Reuses the compute of the first EE layers by using a **Exit Query Cache** that saves only the query vector of the exit layer E−1E−1 so that the verification process won’t need to compute layers 00 to E−1E−1. ([View Highlight](https://read.readwise.io/read/01jd5nj1kzceqmf4r0avp0jj3e))
- So far, the 🤗 transformers library has implemented the first optimization (Shared Weights) in this [pull request](https://github.com/huggingface/transformers/pull/34240). As the number of models that use this method increases, we'll consider the additional optimizations. Feel free to open a PR if you're interested! ([View Highlight](https://read.readwise.io/read/01jd5nj6a9x4fgtmfd3caq5b65))
- The early exit layer of the draft stage is a hyperparameter that we can tune or modify during inference:
  • The earlier we exit, the faster the generation of draft tokens are but the less accurate they will be.
  • The later we exit, the more accurate the draft tokens generated are but the slower their generation will be. ([View Highlight](https://read.readwise.io/read/01jd5njpmj1cq1mbzenqtgxwpc))
- For the baseline checkpoints that have not been pretrained or continually pretrained with the LayerSkip training recipe, early exit self-speculative decoding is slower than autoregressive decoding. This is because during training of most LLMs, earlier layers are not motivated to learn to predict the output, and hence generating tokens using earlier layers will have a very low acceptance rate. ([View Highlight](https://read.readwise.io/read/01jd5njz6v0ma1f0ekxf5sxjmm))
- On the other hand, for the Llama checkpoints that were continually pre-trained with the LayerSkip training, early exit self-speculative decoding has higher speedup than autoregressive decoding for at least a subset of the layers.
  • For most models, except Llama3.2 1B, we notice a regular pattern when we traverse across layers: speedup starts low for the first few layers, increases gradually to a sweet spot, and then decreases again.
  • The early exit layer sweet spot is when we have the optimal tradeoff between high accuracy of predictions and low overhead of generating tokens. This sweet spot depends on each model, and may also depend on the prompt or domain of the prompt. ([View Highlight](https://read.readwise.io/read/01jd5nkj39x5mrtjecsw71g338))
- LayerSkip leverages the synergy between early exit, layer dropout, and cache reuse to create a fast and efficient text generation pipeline. By training the model to unembed outputs from different layers and optimizing the verification process with caches, this approach strikes a balance between speed and accuracy. As a result, it significantly improves inference times in large language models while maintaining high-quality outputs. It also reduces memory compared to traditional speculative decoding techniques due to a single model used as both the draft and verification model. ([View Highlight](https://read.readwise.io/read/01jd5nkpba22q0g68ts1zacwyb))
- Self-speculation is an exciting field where the same LLM can create draft tokens and fix itself. Other self-speculation approaches include:
  • [Draft & Verify](https://aclanthology.org/2024.acl-long.607/): where the draft stage involves skipping pre-determined attention and feed forward layers.
  • [MagicDec](https://arxiv.org/abs/2408.11049): where the draft stage uses a subset of the KV cache, which is useful for long context inputs.
  • [Jacobi Decoding](https://arxiv.org/abs/2305.10427) and [Lookahead Decoding](https://arxiv.org/abs/2402.02057): Where the draft stage are a series of “guess tokens” that could be either random or obtained from a n-gram lookup table. ([View Highlight](https://read.readwise.io/read/01jd5nm6hz53nexz1s0xtrxwc8))
